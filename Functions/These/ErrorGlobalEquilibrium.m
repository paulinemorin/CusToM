function ErrorGlobalEquilibrium = ErrorGlobalEquilibrium(AnalysisParameters, BiomechanicalModel, ModelParameters)
% Prediction of ground reaction forces
%   Ground reaction forces are predicted from motion data.
%
%	Based on :
%	- Fluit, R., Andersen, M. S., Kolk, S., Verdonschot, N., & Koopman, H. F., 2014.
%	Prediction of ground reaction forces and moments during various activities of daily living. Journal of biomechanics, 47(10), 2321-2329.
%	- Skals, S., Jung, M. K., Damsgaard, M., & Andersen, M. S., 2017. 
%	Prediction of ground reaction forces and moments during sports-related movements. Multibody system dynamics, 39(3), 175-195.
%
%   INPUT
%   - filename: name of the file to process (character string)
%   - AnalysisParameters: parameters of the musculoskeletal analysis,
%   automatically generated by the graphic interface 'Analysis' 
%   - BiomechanicalModel: musculoskeletal model
%   - ModelParameters: parameters of the musculoskeletal model, automatically
%   generated by the graphic interface 'GenerateParameters' 
%   OUTPUT
%   - ExternalForcesComputationResults: results of the external forces
%   computation (see the Documentation for the structure)
%________________________________________________________
%
% Licence
% Toolbox distributed under GPL 3.0 Licence
%________________________________________________________
%
% Authors : Antoine Muller, Charles Pontonnier, Pierre Puchaud and
% Georges Dumont
%________________________________________________________

%filename=AnalysisParameters.filename{1,1};
%filename = 'ChgtDirection04';
filename = 'Trial001';

disp(['External Forces Prediction (' filename ') ...'])

AnalysisParameters.ExternalForces.Options(1,1)={'LFoot'};
AnalysisParameters.ExternalForces.Options(2,1)={'RFoot'};


%% Loading data
Human_model = BiomechanicalModel.OsteoArticularModel;
load([filename '/InverseKinematicsResults.mat']); %#ok<LOAD>
q = InverseKinematicsResults.JointCoordinates';
if isfield(InverseKinematicsResults,'FreeJointCoordinates')
    q6dof = InverseKinematicsResults.FreeJointCoordinates';
else
    PelvisPosition = InverseKinematicsResults.PelvisPosition;
    PelvisOrientation = InverseKinematicsResults.PelvisOrientation;
end        
load([filename '/ExperimentalData.mat']); %#ok<LOAD>
time = ExperimentalData.Time;

freq=1/time(2);

nbframe=size(q,1);


%% Stockage résultats
Pelvis_exp = zeros(nbframe,6);
Pelvis_eq = zeros(nbframe,6);

Pelvis_exp_origine = zeros(nbframe,6);
Pelvis_eq_origine = zeros(nbframe,6);

%% Chargement données plateformes

% Loading the Analysis file
%load('AnalysisParameters.mat')

% Get the solid names on which the forces are applied
Solids = AnalysisParameters.ExternalForces.Options;

% Loading the Biomechanicalmodel file
load('BiomechanicalModel.mat')

% Solid list extracted from the OsteoarticularModel
Solid_list = {BiomechanicalModel.OsteoArticularModel.name}';

% Get the numbers of solids on which the forces are applied
[~,num_s]=intersect(Solid_list,Solids);

load([filename '/ExternalForcesComputationResults.mat']); %#ok<LOAD>

GRF_Xp=ExternalForcesComputationResults.ExternalForcesExperiments;

%% Creation of a structure to add contact points
for i=1:numel(AnalysisParameters.Prediction.ContactPoint)
    Prediction(i).points_prediction_efforts = AnalysisParameters.Prediction.ContactPoint{i}; %#ok<AGROW>
end
Prediction=verif_Prediction_Humanmodel(Human_model,Prediction);


%% Gravity
g=[0 0 -9.81]';

%% get rid of the 6DOF joint
if isfield(InverseKinematicsResults,'FreeJointCoordinates')
    Human_model(Human_model(end).child).mother = 0;
    Human_model=Human_model(1:(numel(Human_model)-6));
end

dt=1/freq;
dq=derivee2(dt,q);  % vitesses
ddq=derivee2(dt,dq);  % accélérations

%% Définition des données cinématiques du pelvis
% (position / vitesse / accélération / orientation / vitesse angulaire / accélération angulaire)
% Kinematical data for Pelvis (Position/speed/acceleration/angles/angular speed/angular acceleration)

if isfield(InverseKinematicsResults,'FreeJointCoordinates')
    p_pelvis=q6dof(:,1:3);  % frame i : p_pelvis(i,:)
    r_pelvis=cell(size(q6dof,1),1);
    for i=1:size(q6dof,1)
        r_pelvis{i}=Rodrigues([1 0 0]',q6dof(i,4))*Rodrigues([0 1 0]',q6dof(i,5))*Rodrigues([0 0 1]',q6dof(i,6)); % matrice de rotation en fonction des rotations successives (x,y,z) : frame i : r_pelvis{i}
    end
else
    p_pelvis = cell2mat(PelvisPosition)';
    r_pelvis  = PelvisOrientation';
end

%dR
dR=zeros(3,3,nbframe);
for ligne=1:3
    for colonne=1:3
        dR(ligne,colonne,:)=derivee2(dt,cell2mat(cellfun(@(b) b(ligne,colonne),r_pelvis,'UniformOutput',false)));
    end
end
w=zeros(nbframe,3);
for i=1:nbframe
    wmat=dR(:,:,i)*r_pelvis{i}';
    w(i,:)=[wmat(3,2),wmat(1,3),wmat(2,1)];
end

% v0
v=derivee2(dt,p_pelvis);
vw=zeros(nbframe,3);
for i=1:nbframe
    vw(i,:)=cross(p_pelvis(i,:),w(i,:));
end
v0=v+vw;

% dv0
dv0=derivee2(dt,v0);

% dw
dw=derivee2(dt,w);


%% Calcul frame par frame

Mass = ModelParameters.Mass;

for i=1:nbframe
    %attribution à chaque articulation de la position/vitesse/accélération (position/speed/acceleration for each joint)
    Human_model(1).p=p_pelvis(i,:)';
    Human_model(1).R=r_pelvis{i};
    Human_model(1).v0=v0(i,:)';
    Human_model(1).w=w(i,:)';
    Human_model(1).dv0=dv0(i,:)';
    Human_model(1).dw=dw(i,:)';
    for j=2:numel(Human_model)
        Human_model(j).q=q(i,j); %#ok<*SAGROW>
        Human_model(j).dq=dq(i,j);
        Human_model(j).ddq=ddq(i,j);
    end
    % Calcul positions / vitesses / accélération de chaque solide (computation of position/speed/acceleration for each solid)
    [Human_model,Prediction] = ForwardAllKinematicsPrediction(Human_model,Prediction,1); 
    
    %% Direct optimisation by linearization of the dynamical condition.

    b1=[0 0 0]';
    b2=[0 0 0]';
    
    [~,b1,b2]=InverseDynamicsSolid_lin(Human_model,g,1,b1,b2);
    bf=b1;
    bt=b2+cross(-p_pelvis(i,:)',b1); %on ramene les couples au niveau du pelvis (torques are expressed at pelvis point)
    b=[bf' bt']';
    b_origine=[bf' b2']';
    
    Pelvis_eq(i,:) = b'; 
    Pelvis_eq_origine(i,:) = b_origine'; 
    
    
    for ii=1:numel(num_s)
        cur_s=num_s(ii); %LFoot and RFoot
            % Experimental results
            F_Xp.(Solids{ii})(i,:) = GRF_Xp(i).fext(cur_s).fext(:,1)';
            M_Xp.(Solids{ii})(i,:) = GRF_Xp(i).fext(cur_s).fext(:,2)';
            Pelvis_exp(i, 1:3) = Pelvis_exp(i, 1:3) + F_Xp.(Solids{ii})(i,:);
            Pelvis_exp_origine(i, 1:3) = Pelvis_exp_origine(i, 1:3) + F_Xp.(Solids{ii})(i,:);
            Pelvis_exp(i, 4:6) = Pelvis_exp(i, 4:6) + M_Xp.(Solids{ii})(i,:)+... 
               cross((-p_pelvis(i,:)'),F_Xp.(Solids{ii})(i,:)); % on
               %ramène les couples au niveau du pelvis
            Pelvis_exp_origine(i, 4:6) = Pelvis_exp_origine(i, 4:6) + M_Xp.(Solids{ii})(i,:);
    end
    
    
    
    
end


figure
set(gcf,'color','w')
suptitle(['Global Equilibrium Error expressed at the pelvis: ' filename,char(10)])
Directions={'X','Y','Z'};
for ii=1:3
    subplot(2,3,ii)
    plot(Pelvis_eq(:,ii))
    hold on
    plot(Pelvis_exp(:,ii))
    xlabel('Frames')
    ylabel('Force (N)')
    legend('Predicted','Experimental')
    title(['Force on the ' Directions{ii} '-direction'])
end

for ii=4:6
    subplot(2,3,ii)
    plot(Pelvis_eq(:,ii))
    hold on
    plot(Pelvis_exp(:,ii))
    xlabel('Frames')
    ylabel('Moment (Nm)')
    legend('Predicted','Experimental')
    title(['Moment on the ' Directions{ii-3} '-direction'])
end



figure
set(gcf,'color','w')
suptitle(['Global Equilibrium Error expressed at the frame origine: ' filename ,char(10)])
Directions={'X','Y','Z'};
for ii=1:3
    subplot(2,3,ii)
    plot(Pelvis_eq_origine(:,ii))
    hold on
    plot(Pelvis_exp_origine(:,ii))    
    xlabel('Frames')
    ylabel('Force (N)')
    legend('Predicted','Experimental')
    title(['Force on the ' Directions{ii} '-direction'])
end

for ii=4:6
    subplot(2,3,ii)
    plot(Pelvis_eq_origine(:,ii))
    hold on
    plot(Pelvis_exp_origine(:,ii))
    legend('Predicted','Experimental')
    xlabel('Frames')
    ylabel('Moment (Nm)')
    title(['Moment on the ' Directions{ii-3} '-direction'])
end



end
